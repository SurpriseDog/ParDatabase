#!/usr/bin/python3
# An autogenerated selection of SurpriseDog's common functions relevant to this project.
# To see how this file was created visit: https://github.com/SurpriseDog/Star-Wrangler

import re
import sys
import time
import math


def list_get(lis, index, default=''):
    '''Fetch a value from a list if it exists, otherwise return default
    Now accepts negative indexes'''

    length = len(lis)
    if -length <= index < length:
        return lis[index]
    else:
        return default


def search_list(expr, the_list, get='all', func='match', ignorecase=True, searcher=None):
    '''Search for expression in each item in list (or dictionary!)
    get = 'all'     = Return all items found <Default>
          'first'   = Return the first value found, otherwise None
          'only'    = Return only one item, error if more
          'exactly' = Return one item, error if more or less than one

    searcher = Custom lamda function'''

    if not searcher:
        # func = dict(search='in').get('search', func)
        # Avoiding regex now in case substring has a regex escape character
        if ignorecase:
            expr = expr.lower()
        if func in ('in', 'search'):
            if ignorecase:
                def searcher(expr, item):         # pylint: disable=E0102
                    return expr in item.lower()
            else:
                def searcher(expr, item):         # pylint: disable=E0102
                    return expr in item
        elif func == 'match':
            if ignorecase:
                def searcher(expr, item):         # pylint: disable=E0102
                    return item.lower().startswith(expr)
            else:
                def searcher(expr, item):         # pylint: disable=E0102
                    return item.startswith(expr)
        else:
            # Could have nested these, but this is faster.
            raise ValueError("Unknown search type:", func)

    output = []
    for item in the_list:
        if searcher(expr, item):
            if isinstance(the_list, dict):
                output.append(the_list[item])
            else:
                output.append(item)
            if get == 'first':
                return output[0]
    else:
        if get == 'first':
            return None

    if get == 'one':
        if len(output) == 1:
            return output[0]
        elif not output:
            return None
        else:
            raise ValueError("Too many items found in list!")

    if get == 'only':
        if len(output) != 1:
            raise ValueError("Found", len(output), "items in list!")
        else:
            return output[0]

    return output


def bisect_small(lis, num):
    '''Given a sorted list, returns the index of the biggest number <= than num
    Unlike bisect will never return an index which doesn't exist'''
    end = len(lis) - 1
    for x in range(end + 1):
        if lis[x] >= num:
            return max(x - 1, 0)
    else:
        return end


def sig(num, digits=3):
    "Return number formatted for significant digits"
    num = float(num)
    if num == 0:
        return '0'
    negative = '-' if num < 0 else ''
    num = abs(num)
    power = math.log(num, 10)
    if num < 1:
        num = int(10**(-int(power) + digits) * num)
        return negative + '0.' + '0' * -int(power) + str(int(num)).rstrip('0')
    elif power < digits - 1:
        return negative + ('{0:.' + str(digits) + 'g}').format(num)
    else:
        return negative + str(int(num))


def undent(text, tab=''):
    "Remove whitespace at the beginning of lines of text"
    return '\n'.join([tab + line.lstrip() for line in text.splitlines()])


class Eprinter:
    '''Drop in replace to print errors if verbose level higher than setup level
    To replace every print statement type: from common import eprint as print

    eprint(v=-1)    # Normally hidden messages
    eprint(v=0)     # Default level
    eprint(v=1)     # Priority messages
    eprint(v=2)     # Warnings
    eprint(v=3)     # Errors
    '''

    # Setup: eprint = Eprinter(<verbosity level>).eprint
    # Simple setup: from common import eprint
    # Usage: eprint(messages, v=1)

    # Don't forget they must end in 'm'
    BOLD = '\033[1m'
    WARNING = '\x1b[1;33;40m'
    FAIL = '\x1b[0;31;40m'
    END = '\x1b[0m'

    def __init__(self, verbose=0):
        self.level = verbose
        self.history = []

        # If string starts with '\n', look at history to make sure previous newlines don't exist
        self.autonewlines = True

    def newlines(self, num=1):
        "Print the required number of newlines after checking history to make sure they exist."
        lines = sum([1 for line in self.history[-num:] if not line.strip()])
        num -= lines
        if num:
            print('\n' * (num), end='')
        return num


    def eprint(self, *args, v=0, color=None, header=None, **kargs):
        '''Print to stderr
        Custom color example: color='1;33;40'
        More colors: https://stackoverflow.com/a/21786287/11343425
        '''
        verbose = v
        # Will print if verbose >= level
        if verbose < self.level:
            return 0

        if not color:
            if v == 2 and not color:
                color = f"{self.WARNING}"
            if v >= 3 and not color:
                color = f"{self.FAIL}" + f"{self.BOLD}"
        else:
            color = '\x1b[' + color + 'm'

        msg = ' '.join(map(str, args))
        if self.autonewlines:
            match = re.match('^\n*', msg)
            if match:
                num = self.newlines(match.span()[1])
                if num:
                    # print('created', num, 'newlines', repr(msg[:64]))
                    msg = msg.lstrip('\n')


        self.history += msg.splitlines()
        if len(self.history) > 64:
            self.history = self.history[64:]

        if header:
            msg = header + ' ' + msg
        if color:
            print(color + msg + f"{self.END}", file=sys.stderr, **kargs)
        else:
            print(msg, file=sys.stderr, **kargs)
        return len(msg)


def warn(*args, header="\n\nWarning:", sep=' ', delay=1 / 64, confirm=False):
    msg = undent(sep.join(list(map(str, args))))
    time.sleep(eprint(msg, header=header, v=2) * delay)
    if confirm:
        _nul = input()


eprint = Eprinter(verbose=1).eprint     # pylint: disable=C0103

'''
&&&&%%%%%&@@@@&&&%%%%##%%%#%%&@@&&&&%%%%%%/%&&%%%%%%%%%%%&&&%%%%%&&&@@@@&%%%%%%%
%%%%%%%%&@&(((((#%%&%%%%%%%%%&@@&&&&&&%%%&&&&&%%%%%%%%%%%&&&&%&%#((((/#@@%%%%%%%
&&%%%%%%&@(*,,,,,,,/%&%%%%%%%&@@&&&&&%%&&&&%%&&%%%%%%%%%%&&&%#*,,,,,,*/&@&%%%%%%
%%%%%%%&@&/*,,,*,*,,*/%&%%%%%&@@&&&&&&%%&&&&&&&%%%%%%&%%%&&%*,,,,,,,,**#@&&%%%%%
&&&&&%%&@#(**********,*(#&%%%&@&&&&%%%%%%%%%&&&%%%%%%&%&&#*****,*******#@&&%%%%%
&&&%%%&&#/***/*****/*,**,*%&%&@@&&&&&&&&&&&&&&&%%%%%%&&#*,,,*/******/***(%&%%%%%
&&&%%%&%/*****///////**,,,,*/%%&&@@@@@@@@@@@@@@@@&&%#*,,,*,*(///////*****#%&%%%%
@@&%%#&#/,,,*/(//((((//**,,*/#&@@@@@&&&&&&&&&&@@@@@%(/*,,**/(/(((/(//*,,*(&&%%%%
&&&%##&#*,,,*////((((/*///(&@&@@&&&#%((//(/###%&@&@@@@#//**//(#(///***,.,/&&%%%%
%%%%%#%#*,,,**////(///((#&&&%@&%%(/*,,......,,/(#%&&&@@@%((/(/#(///**,,,,(&%%%%%
&&%%%#%%/,..***//(#(#%%&@@@&@%(*.,,..       ...,.,/#@&@@@&&%#(((///**,..,#%%%%%%
%&%%%%%#*,****/(##&@@@&@@@@&%*,....           ....,,(&@@@@@@&@&%((//****,(%%%%%%
%&%%%%%#/,**/#&@@@&@@@@@@@&(*,......    .     ..,..,.(&@@@@@@@&@@@&%#**,*(%%%%%%
&&%%%%#&#(#&@@@&@@@@@@@@%((#@@%&&((,,,,,..,,(**(%@@&@%##(&@@@@@@@@&&@@%#(%%%%%%%
&&&%%%%%&&&&&&@@@@@@%###%@(,%&/@@&(%(/*,..,*/%##&&,%@(*&@#((%&@@@@@@&&@&%%%%&&%%
&&%%%%%%&&&@@@@@@@@#((*#@%,#%%&@#%(/**//,****/(#%%%&&%*(@@*/#(&@@@@@@@&&%%%%%%%%
&&&%%%%%&@@@@&%#/,,,,*,(/%&@@&((%(*,*,,*,**,,*,*#%(#@@&%((**,,,,*#(%&@@&&%%%%%%%
&&&%%%%%@@@@%*/*,...,*,,/*#(//#****,***********,**/#/##(/*,*,...,*/*/&@@&%%&%%%%
&&%%%%%%&@@@(//,....,,*/****/,,/**************/***/,,//**/**,....,*//&@@&%%&%%%%
&&&%%%%%&@@%(/*,. ...,****/*/(//*%&@@&%%%%%%&&&&//*/(*/**/**......,/*#&@&%&&&&%%
&&%%%%%%&@@%(**,,....,/**/((/,#&&&&&%#((((((%&&&@&%/*/(/**/*,. ..,,*/((#@&&&&&&%
%&%%%%%%&&#(/**,..,,,***/((,./%&%&&&@&(/#((#@@&&&%&%,,/((*,/*,,..,,,///(%&%&&&&&
&&%%%%%%&#,**,.,..,,*(//(/,,.,&&&@#&@@##%(#&@&%%@&&#.,,/(((//*,,..,,**,*&%&&%&&&
&&%##%%%#/**,,,,..,*/((((*...,,#&##%(#%%&%%###%(%&/,.. **((((/,...,,,,**(%%#%%%&
&&%####(**,,,.,,.,,/(/(//*,,..../%&(##%&&&%%(#%&#, .. .**//(/(*,,..,.,,**/((#%%%
&&&%#///*,........,/(((//**,.   ,,(#%%%%%%&#%##**.   ,,*//((((*,........,*//(%%%
%%%%(/**...       .,/(((///*., .,*(#(%%%%%%%%##/*,..,,*///((/*.      .....**/(%%
%%%%#(,..          .,/((/(//****,/(((###%#%(#///**,,**/((/((*,          .,.,(%%%
&&%%%#/*...          ,*/(/(/((%%&#&#(/%./.*%(#%#%#&&(((/(/*,.          ..,**(&%%
&&%%%%(*.....          ..*((/**(#&&&&&&&%%%&%&&&%(/,*/((*..           .,..*(&&%%
&&%%%%&#*.      .        */(#/*,,*/((%#%%%%%((**,.*/(#(/,       .       ,(%&%%&%
%%%%%%&%#//**,..           .**(((*,...,,**,,..*,/((/*,.          ...,,//(#%%%%%%
%%%&&&%(/*,**,..,,.,..       .,,**//**,*,,,*,////*,,.        .,.,...,,,**//#%&%%
%%%&&%#/*,*,.    ...      ..         ...  ,.. .       .       ...   ..,,*/(#%&%%
&&&&&%(((*.*... . .*,.   .           .*%%#(,.          .    .*,. ..,.,,**/(%#&%%

Generated by https://github.com/SurpriseDog/Star-Wrangler
a Python tool for picking only the required code from source files
written by SurpriseDog at: https://github.com/SurpriseDog
2022-08-29
'''
