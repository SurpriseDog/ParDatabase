#!/usr/bin/python3
# An autogenerated selection of SurpriseDog's common functions relevant to this project.
# To see how this file was created visit: https://github.com/SurpriseDog/Star-Wrangler

import re
import sys
import time
import math
from shutil import get_terminal_size


def map_nested(func, array):
    "Apply a function to a nested array and return it"
    out = []
    for item in array:
        if type(item) not in (tuple, list):
            out.append(func(item))
        else:
            out.append(map_nested(func, item))
    return out


def expand_newlines(line):
    "Take a list with newlines in it and split into 2d array while maintaining column position"
    out = [[''] * len(line)]
    for x, section in enumerate(line):
        if '\n' in section:
            for y, elem in enumerate(section.split('\n')):
                if y >= len(out):
                    out.append([''] * len(line))
                out[y][x] = elem
        else:
            out[0][x] = section
    return out


def indenter(*args, header='', level=0, tab=4, wrap=-4, even=False):
    '''
    Break up text into tabbed lines.
    Wrap at max characters:
    0 = Don't wrap
    negative = wrap to terminal width minus wrap
    '''
    if wrap < 0:
        wrap = TERM_WIDTH + wrap

    if type(tab) == int:
        tab = ' ' * tab
    header = str(header) + tab * level
    words = (' '.join(map(str, args))).split(' ')

    lc = float('inf')       # line count
    for cut in range(wrap, -1, -1):
        out = []
        line = ''
        count = 0
        for word in words:
            if count:
                new = line + ' ' + word
            else:
                new = header + word
            count += 1
            if cut and len(new.replace('\t', ' ' * 4)) > cut:
                out.append(line)
                line = header + word
            else:
                line = new
        if line:
            out.append(line)
        if not even:
            return out
        if len(out) > lc:
            return prev
        prev = out.copy()
        lc = len(out)
    return out


def print_columns(args, col_width=20, columns=None, just='left', space=0, wrap=True):
    '''Print columns of col_width size.
    columns = manual list of column widths
    just = justification: left, right or center'''

    if not columns:
        columns = [col_width] * len(args)

    output = ""
    extra = []
    for count, section in enumerate(args):
        width = columns[count]
        section = str(section)

        if wrap:
            lines = None
            if len(section) > width - space:
                lines = indenter(section, wrap=width - space)
                if len(lines) >= 2 and len(lines[-1]) <= space:
                    lines[-2] += lines[-1]
                    lines.pop(-1)
            if '\n' in section:
                lines = section.split('\n')
            if lines:
                section = lines[0]
                for lineno, line in enumerate(lines[1:]):
                    if lineno + 1 > len(extra):
                        extra.append([''] * len(args))
                    extra[lineno][count] = line

        output += _just2func(just)(section, width)
    print(output)

    for line in extra:
        print_columns(line, col_width, columns, just, space, wrap=False)


def _fit_in_width(col_width, max_width):
    "Adjust array of column widths to fit inside a maximum"
    extra = sum(col_width) - max_width          # Amount columns exceed the terminal width

    def fill_remainder():
        "After operation to reduce column sizes, use up any remaining space"
        remain = max_width - sum(col_width)
        for x, _ in enumerate(col_width):
            if remain:
                col_width[x] += 1
                remain -= 1

    # Reduce column widths to fit in terminal
    if extra > 0:
        if max(col_width) > 0.5 * sum(col_width):
            # If there's one large column, reduce it
            index = col_width.index(max(col_width))
            col_width[index] -= extra
            if col_width[index] < max_width // len(col_width):
                # However if that's not enough reduce all columns equally
                col_width = [max_width // len(col_width)] * len(col_width)
                fill_remainder()
        else:
            # Otherwise reduce all columns proportionally
            col_width = [int(width * (max_width / (max_width + extra))) for width in col_width]
            fill_remainder()
        # print(col_width, '=', sum(col_width))
    return col_width


def crop_columns(array, crop):
    "Given a 2d array, crop any cell which exceeds the crop value and append ..."
    out = []
    for row in array:
        line = []
        for index, item in enumerate(row):
            cut = crop.get(index, 0)
            length = len(item)
            if length > cut > 3:
                line.append(item[:cut-3]+'...')
            elif cut > 0:
                line.append(item[:cut])
            else:
                line.append(item)
        out.append(line)
    return out


def _just2func(just):
    "Given a justification of left, right, center : convert to function"
    j = just.lower()[0]
    if j == 'l':
        return str.ljust
    elif j == 'r':
        return str.rjust
    elif j == 'c':
        return str.center
    else:
        raise ValueError("Cannot understand justification:", just)


def auto_columns(array, space=4, manual=None, printme=True, wrap=0, crop=None, just='left'):
    '''Automatically adjust column size
    Takes in a 2d array and prints it neatly
    space = spaces between columns
    manual = dictionary of column adjustments made to space variable
    crop = dict of max length for each column, 0 = unlimited
        example: {-1:2} sets the space variable to 2 for the last column
    wrap = wrap at this many columns. 0 = terminal width
    printme = False : return array instead of printing it
    '''
    if not manual:
        manual = dict()

    # Convert generators and map objects:
    array = map_nested(str, array)

    # Find any \n and bump it to the next line of array
    for index, line in reversed(list(enumerate(array))):
        if '\n' in ''.join(line):
            array.pop(index)
            for l2 in reversed(expand_newlines(line)):
                array.insert(index, l2)

    if crop:
        array = crop_columns(array, crop)


    # Fixed so array can have inconsistently sized rows
    col_width = {}
    for row in array:
        row = list(map(str, row))
        for col, _ in enumerate(row):
            length = len(row[col])
            if col not in col_width or length > col_width[col]:
                col_width[col] = length

    col_width = [col_width[key] for key in sorted(col_width.keys())]
    spaces = [space] * len(col_width)
    if spaces:
        spaces[-1] = 0

    # Make any manual adjustments
    for col, val in manual.items():
        spaces[col] = val

    col_width = [sum(x) for x in zip(col_width, spaces)]

    # Adjust for line wrap and fit in terminal
    max_width = TERM_WIDTH - 1 # Terminal size
    if wrap < 0:
        wrap = max_width + wrap
    if wrap:
        max_width = min(max_width, wrap)
    col_width = _fit_in_width(col_width, max_width)

    '''
    # Turn on for visual representation of columns:
    print(col_width)
    print(''.join([str(count) * x  for count, x in enumerate(col_width)]))
    for line in array:
        print(line)
    '''

    if printme:
        for row in array:
            print_columns(row, columns=col_width, space=0, just=just)
        return None
    else:
        out = []
        op = _just2func(just)
        for row in array:
            line = []
            for index, item in enumerate(row):
                line.append(op(item, col_width[index]))
            out.append(line)
        return out


def list_get(lis, index, default=''):
    '''Fetch a value from a list if it exists, otherwise return default
    Now accepts negative indexes'''

    length = len(lis)
    if -length <= index < length:
        return lis[index]
    else:
        return default


def search_list(expr, the_list, get='all', func='match', ignorecase=True, searcher=None):
    '''Search for expression in each item in list (or dictionary!)
    get = 'all'     = Return all items found <Default>
          'first'   = Return the first value found, otherwise None
          'only'    = Return only one item, error if more
          'exactly' = Return one item, error if more or less than one

    searcher = Custom lamda function'''

    if not searcher:
        # func = dict(search='in').get('search', func)
        # Avoiding regex now in case substring has a regex escape character
        if ignorecase:
            expr = expr.lower()
        if func in ('in', 'search'):
            if ignorecase:
                def searcher(expr, item):         # pylint: disable=E0102
                    return expr in item.lower()
            else:
                def searcher(expr, item):         # pylint: disable=E0102
                    return expr in item
        elif func == 'match':
            if ignorecase:
                def searcher(expr, item):         # pylint: disable=E0102
                    return item.lower().startswith(expr)
            else:
                def searcher(expr, item):         # pylint: disable=E0102
                    return item.startswith(expr)
        else:
            # Could have nested these, but this is faster.
            raise ValueError("Unknown search type:", func)

    output = []
    for item in the_list:
        if searcher(expr, item):
            if isinstance(the_list, dict):
                output.append(the_list[item])
            else:
                output.append(item)
            if get == 'first':
                return output[0]
    else:
        if get == 'first':
            return None

    if get == 'one':
        if len(output) == 1:
            return output[0]
        elif not output:
            return None
        else:
            raise ValueError("Too many items found in list!")

    if get == 'only':
        if len(output) != 1:
            raise ValueError("Found", len(output), "items in list!")
        else:
            return output[0]

    return output


def bisect_small(lis, num):
    '''Given a sorted list, returns the index of the biggest number <= than num
    Unlike bisect will never return an index which doesn't exist'''
    end = len(lis) - 1
    for x in range(end + 1):
        if lis[x] >= num:
            return max(x - 1, 0)
    else:
        return end


def sig(num, digits=3):
    "Return number formatted for significant digits"
    num = float(num)
    if num == 0:
        return '0'
    negative = '-' if num < 0 else ''
    num = abs(num)
    power = math.log(num, 10)
    if num < 1:
        num = int(10**(-int(power) + digits) * num)
        return negative + '0.' + '0' * -int(power) + str(int(num)).rstrip('0')
    elif power < digits - 1:
        return negative + ('{0:.' + str(digits) + 'g}').format(num)
    else:
        return negative + str(int(num))


class Eprinter:
    '''Drop in replace to print errors if verbose level higher than setup level
    To replace every print statement type: from common import eprint as print

    eprint(v=-1)    # Normally hidden messages
    eprint(v=0)     # Default level
    eprint(v=1)     # Priority messages
    eprint(v=2)     # Warnings
    eprint(v=3)     # Errors
    '''

    # Setup: eprint = Eprinter(<verbosity level>).eprint
    # Simple setup: from common import eprint
    # Usage: eprint(messages, v=1)

    # Don't forget they must end in 'm'
    BOLD = '\033[1m'
    WARNING = '\x1b[1;33;40m'
    FAIL = '\x1b[0;31;40m'
    END = '\x1b[0m'

    def __init__(self, verbose=0):
        self.level = verbose
        self.history = []

        # If string starts with '\n', look at history to make sure previous newlines don't exist
        self.autonewlines = True

    def newlines(self, num=1):
        "Print the required number of newlines after checking history to make sure they exist."
        lines = sum([1 for line in self.history[-num:] if not line.strip()])
        num -= lines
        if num:
            print('\n' * (num), end='')
        return num


    def eprint(self, *args, v=0, color=None, header=None, **kargs):
        '''Print to stderr
        Custom color example: color='1;33;40'
        More colors: https://stackoverflow.com/a/21786287/11343425
        '''
        verbose = v
        # Will print if verbose >= level
        if verbose < self.level:
            return 0

        if not color:
            if v == 2 and not color:
                color = f"{self.WARNING}"
            if v >= 3 and not color:
                color = f"{self.FAIL}" + f"{self.BOLD}"
        else:
            color = '\x1b[' + color + 'm'

        msg = ' '.join(map(str, args))
        if self.autonewlines:
            match = re.match('^\n*', msg)
            if match:
                num = self.newlines(match.span()[1])
                if num:
                    # print('created', num, 'newlines', repr(msg[:64]))
                    msg = msg.lstrip('\n')


        self.history += msg.splitlines()
        if len(self.history) > 64:
            self.history = self.history[64:]

        if header:
            msg = header + ' ' + msg
        if color:
            print(color + msg + f"{self.END}", file=sys.stderr, **kargs)
        else:
            print(msg, file=sys.stderr, **kargs)
        return len(msg)


def undent(text, tab=''):
    "Remove whitespace at the beginning of lines of text"
    return '\n'.join([tab + line.lstrip() for line in text.splitlines()])


def warn(*args, header="\n\nWarning:", sep=' ', delay=1 / 64, confirm=False):
    msg = undent(sep.join(list(map(str, args))))
    time.sleep(eprint(msg, header=header, v=2) * delay)
    if confirm:
        _nul = input()


auto_cols = auto_columns    # pylint: disable=C0103
TERM_WIDTH = max(get_terminal_size().columns, 20)
eprint = Eprinter(verbose=1).eprint     # pylint: disable=C0103

'''
&&&&%%%%%&@@@@&&&%%%%##%%%#%%&@@&&&&%%%%%%/%&&%%%%%%%%%%%&&&%%%%%&&&@@@@&%%%%%%%
%%%%%%%%&@&(((((#%%&%%%%%%%%%&@@&&&&&&%%%&&&&&%%%%%%%%%%%&&&&%&%#((((/#@@%%%%%%%
&&%%%%%%&@(*,,,,,,,/%&%%%%%%%&@@&&&&&%%&&&&%%&&%%%%%%%%%%&&&%#*,,,,,,*/&@&%%%%%%
%%%%%%%&@&/*,,,*,*,,*/%&%%%%%&@@&&&&&&%%&&&&&&&%%%%%%&%%%&&%*,,,,,,,,**#@&&%%%%%
&&&&&%%&@#(**********,*(#&%%%&@&&&&%%%%%%%%%&&&%%%%%%&%&&#*****,*******#@&&%%%%%
&&&%%%&&#/***/*****/*,**,*%&%&@@&&&&&&&&&&&&&&&%%%%%%&&#*,,,*/******/***(%&%%%%%
&&&%%%&%/*****///////**,,,,*/%%&&@@@@@@@@@@@@@@@@&&%#*,,,*,*(///////*****#%&%%%%
@@&%%#&#/,,,*/(//((((//**,,*/#&@@@@@&&&&&&&&&&@@@@@%(/*,,**/(/(((/(//*,,*(&&%%%%
&&&%##&#*,,,*////((((/*///(&@&@@&&&#%((//(/###%&@&@@@@#//**//(#(///***,.,/&&%%%%
%%%%%#%#*,,,**////(///((#&&&%@&%%(/*,,......,,/(#%&&&@@@%((/(/#(///**,,,,(&%%%%%
&&%%%#%%/,..***//(#(#%%&@@@&@%(*.,,..       ...,.,/#@&@@@&&%#(((///**,..,#%%%%%%
%&%%%%%#*,****/(##&@@@&@@@@&%*,....           ....,,(&@@@@@@&@&%((//****,(%%%%%%
%&%%%%%#/,**/#&@@@&@@@@@@@&(*,......    .     ..,..,.(&@@@@@@@&@@@&%#**,*(%%%%%%
&&%%%%#&#(#&@@@&@@@@@@@@%((#@@%&&((,,,,,..,,(**(%@@&@%##(&@@@@@@@@&&@@%#(%%%%%%%
&&&%%%%%&&&&&&@@@@@@%###%@(,%&/@@&(%(/*,..,*/%##&&,%@(*&@#((%&@@@@@@&&@&%%%%&&%%
&&%%%%%%&&&@@@@@@@@#((*#@%,#%%&@#%(/**//,****/(#%%%&&%*(@@*/#(&@@@@@@@&&%%%%%%%%
&&&%%%%%&@@@@&%#/,,,,*,(/%&@@&((%(*,*,,*,**,,*,*#%(#@@&%((**,,,,*#(%&@@&&%%%%%%%
&&&%%%%%@@@@%*/*,...,*,,/*#(//#****,***********,**/#/##(/*,*,...,*/*/&@@&%%&%%%%
&&%%%%%%&@@@(//,....,,*/****/,,/**************/***/,,//**/**,....,*//&@@&%%&%%%%
&&&%%%%%&@@%(/*,. ...,****/*/(//*%&@@&%%%%%%&&&&//*/(*/**/**......,/*#&@&%&&&&%%
&&%%%%%%&@@%(**,,....,/**/((/,#&&&&&%#((((((%&&&@&%/*/(/**/*,. ..,,*/((#@&&&&&&%
%&%%%%%%&&#(/**,..,,,***/((,./%&%&&&@&(/#((#@@&&&%&%,,/((*,/*,,..,,,///(%&%&&&&&
&&%%%%%%&#,**,.,..,,*(//(/,,.,&&&@#&@@##%(#&@&%%@&&#.,,/(((//*,,..,,**,*&%&&%&&&
&&%##%%%#/**,,,,..,*/((((*...,,#&##%(#%%&%%###%(%&/,.. **((((/,...,,,,**(%%#%%%&
&&%####(**,,,.,,.,,/(/(//*,,..../%&(##%&&&%%(#%&#, .. .**//(/(*,,..,.,,**/((#%%%
&&&%#///*,........,/(((//**,.   ,,(#%%%%%%&#%##**.   ,,*//((((*,........,*//(%%%
%%%%(/**...       .,/(((///*., .,*(#(%%%%%%%%##/*,..,,*///((/*.      .....**/(%%
%%%%#(,..          .,/((/(//****,/(((###%#%(#///**,,**/((/((*,          .,.,(%%%
&&%%%#/*...          ,*/(/(/((%%&#&#(/%./.*%(#%#%#&&(((/(/*,.          ..,**(&%%
&&%%%%(*.....          ..*((/**(#&&&&&&&%%%&%&&&%(/,*/((*..           .,..*(&&%%
&&%%%%&#*.      .        */(#/*,,*/((%#%%%%%((**,.*/(#(/,       .       ,(%&%%&%
%%%%%%&%#//**,..           .**(((*,...,,**,,..*,/((/*,.          ...,,//(#%%%%%%
%%%&&&%(/*,**,..,,.,..       .,,**//**,*,,,*,////*,,.        .,.,...,,,**//#%&%%
%%%&&%#/*,*,.    ...      ..         ...  ,.. .       .       ...   ..,,*/(#%&%%
&&&&&%(((*.*... . .*,.   .           .*%%#(,.          .    .*,. ..,.,,**/(%#&%%

Generated by https://github.com/SurpriseDog/Star-Wrangler
a Python tool for picking only the required code from source files
written by SurpriseDog at: https://github.com/SurpriseDog
2022-08-29
'''
